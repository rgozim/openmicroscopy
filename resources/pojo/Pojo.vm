$pojo.getPackageDeclaration()

$secondpassclassimports

$templates.PojoTypeDeclaration 
{

#if(!$pojo.isInterface())

$templates.PojoFields

###########################################################
## <CustomCode>
###########################################################
##$templates.PojoConstructors
    // Constructors

    /** default constructor */
    public $pojo.getDeclarationName()() {}
#if($clazz.identifierProperty)
	/** default constructor which sets id */
    public $pojo.getDeclarationName()(Long id){
		setId(id);
		getDetails().setContext(this);
	}
	/** constructor which sets id and permits the "unloading" of the object */
	public $pojo.getDeclarationName()(Long id, boolean loaded)
	{
		this(id);
		if (!loaded){
			unload();
		}
	}
#end
##
################################################################################
## PROPERY LEVEL EXTRA METHODS
################################################################################
##
#foreach($property in $pojo.getAllPropertiesIterator())
#set( $PropertyName = $pojo.beanCapitalize( $property.name ) )
#set( $fieldtype =  $pojo.getJavaTypeName($property, $jdk5) )
#set( $elementtype = $c2j.getJavaTypeName($property,true).replaceFirst(".*<","").replaceFirst(">.*",""))
#if( $c2j.hasMetaAttribute($property, "set-add-method") || $c2j.hasMetaAttribute($property, "link-add-method") )

	private Set ${property.name} = new HashSet(0);

	/** 
	 * returns ${property.name} . You should not modify this Set unless you
	 * know what you are doing. Use the iterate method instead.
	 */
    protected $fieldtype get${PropertyName}() {
        return this.${property.name};
    }
	
	/** 
	 * setter for ${property.name} should be avoided. Does not fulfill normal semantics.
	 */
    protected void set${PropertyName}($fieldtype ${property.name}) {
        this.${property.name} = ${property.name};
    }

	/**
	 * returns the size of ${property.name}. If less than zero, the Set was null.
	 */
	public int sizeOf${PropertyName}() {
		return this.${property.name} == null ? -1 : this.${property.name}.size();
	}

	/**
	 * should be used rather than accessing the ${property.name} set directly.
	 */ 
	public Iterator iterate${PropertyName}() {
	
		if ( get${PropertyName}() == null )
		{
			return new ome.util.EmptyIterator();
		}
		return get${PropertyName}().iterator();
	}

	/**
	 * takes a CBlock and calls the block once for each $elementtype while 
	 * collecting the results. If <code>block == null</code>, then the 
	 * iterator values themselves are collected.
	 */ 
	public List collect${PropertyName}(ome.util.CBlock block) {
		List result = new ArrayList();
		Iterator it = iterate${PropertyName}();
		while ( it.hasNext() )
		{
			IObject obj = (IObject) it.next();
			if ( block != null )
			{
				result.add( block.call( obj ) );
			} else {
				result.add( obj );
			}
				
		}
		return result;
	}
	
#end
## 
## SETS: These methods represent our handling of Hibernate's "inverse" sets
##       which do not act as expected with regards to getters & setters.
##
#if( $c2j.hasMetaAttribute($property, "set-add-method") )
#set( $inverse = $pojo.beanCapitalize( $c2j.getMetaAsString($property, "set-add-method")))
	/** 
	 * use instead of set${PropertyName} . Makes the necessary
	 * call on $elementtype as well.
	 */
	public void addTo${PropertyName}($elementtype target) {

		if ( get${PropertyName}() == null )
			set${PropertyName}( new HashSet() );
			
		get${PropertyName}().add( target );
		target.set${inverse} ( this );
	}

	/** 
	 * use like addTo${PropertyName}. 
	 */
	public void addAllTo${PropertyName}(Set targets) {
		Iterator it = targets.iterator();
		while ( it.hasNext() )
		{
		  $elementtype target = ($elementtype) it.next();
		  target.set${inverse} ( this );
		}
		
		if ( get${PropertyName}() == null )
			set${PropertyName}( new HashSet() );

		get${PropertyName}().addAll( targets );
		
	}
	
	/**
	 * removes a single element from this set and makes the inverse call on ${elementtype} 
	 */
	public void removeFrom${PropertyName}(${elementtype} target) {
		target.set${inverse} ( null );
		
		if ( get${PropertyName}() != null )
			get${PropertyName}().remove( target );
			
	}

	/**
	 * use like removeFrom${PropertyName}
	 */
	public void removeAllFrom${PropertyName}( Set targets ) {
		Iterator it = targets.iterator();
		while ( it.hasNext() ) 
		{
			${elementtype} target = ($elementtype) it.next();
			target.set${inverse} ( null );
		}
		
		if ( get${PropertyName}() != null )
			get${PropertyName}().removeAll( targets );
			
	}
	
	/**
	 * clears the set. 
	 */
	public void clear${PropertyName}() {
		Iterator it = iterate${PropertyName}();
		while ( it.hasNext() )
		{
			$elementtype target = ($elementtype) it.next();
			target.set${inverse} ( null );
		}
		
		if ( get${PropertyName}() != null )
			get${PropertyName}().clear();
			
	}
	
## 
## LINK: These methods are like the set methods above, but help to completely
##       hide the link implementations.
##
#elseif( $c2j.hasMetaAttribute($property, "link-add-method") )
#set( $elementtype = $c2j.getMetaAsString($property, "link-add-method"))
#set( $Name = $c2j.unqualify( $elementtype ) )
#set( $LinkType = $c2j.getJavaTypeName($property,true).replaceFirst(".*<","").replaceFirst(">.*",""))
#set( $Link = $c2j.unqualify( $LinkType ) )
#set( $order = $c2j.getMetaAsString($property, "link-add-order"))
#set( $next = $c2j.getMetaAsString($property, "link-add-next"))
#set( $other = $c2j.getMetaAsString($property, "link-add-other"))
	
	/**
	 * adds a $elementtype to ${property.name} . This entails changing our ${property.name} Set,
	 * creating a new $LinkType and calling link${pojo.declarationName} on the $elementtype
	 */
	public void link${Name} ($elementtype addition) {

		// Setup link
		$LinkType link = new $LinkType();
		link.link( $order );
		
		// Add it to us and possibly the other side.
		add${Link}( link, true );

	}
	
	/**
	 * adds a $LinkType to ${property.name}, allowing for recursion -- whether
	 * or not add${Name} will be called on the addition.
	 */ 
	public void add${Link} ($LinkType link, boolean bothSides) {
		
		if ( get${PropertyName}() == null )
			set${PropertyName}( new HashSet() );

		get${PropertyName}().add( link );

		if (bothSides)
			link.${other}().add${Link}( link, false );
		
	}

	/**
	 * provides an iterator over the $next values of the ${property.name}
	 */ 
	 public Iterator linked${Name}Iterator() {
		if ( get${PropertyName}() == null )
			return new ome.util.EmptyIterator();
			
        final Iterator it = get${PropertyName}().iterator();
        return new Iterator() {

            public boolean hasNext()
            {
                return it == null ? false : it.hasNext();
            }

            public Object next()
            {
                if ( it == null ) throw new NoSuchElementException( 
					"$property.name is null; no elements." );
					
                $LinkType link = ($LinkType) it.next();
                return link.${other}();
            }

            public void remove()
            {
                throw new UnsupportedOperationException("Cannot call remove on this iterator.");
            }
            
        };

    }

	/** 
	 * find all ${LinkType} which have the argument as their $other. 
	 */
	public Set find${Link}( $elementtype target ) {
        final Iterator it = iterate${PropertyName}();
        final Set result = new HashSet();
        while ( it.hasNext() )
        {
            $LinkType link = ($LinkType) it.next();
            if ( link.${other}() == target ) {
                result.add( link );
            }
        }
        return result;
    }

	public List linked${Name}List() {
		if ( get${PropertyName}() == null) return new ArrayList();
		return new ArrayList( get${PropertyName}() );
	}
	
	/**
	 * takes a CBlock and calls the block once for each $elementtype while 
	 * collecting the results. If <code>block == null</code>, then the 
	 * iterator values themselves are collected.
	 */ 
	public List eachLinked${Name}(ome.util.CBlock block) {
		List result = new ArrayList();
		Iterator it = linked${Name}Iterator();
		while ( it.hasNext() )
		{
			IObject obj = (IObject) it.next();
			if ( block != null )
			{
				result.add( block.call( obj ) );
			} else {
				result.add( obj );
			}
				
		}
		return result;
	}
	
	/**
	 * unlinks all $elementtype instances from this instance. 
	 */
	public void unlink${Name} ($elementtype removal) {
		Set toRemove = find${Link}( removal );
		Iterator it = toRemove.iterator();
		while ( it.hasNext() )
		{
			remove${Link}( ($LinkType) it.next(), true );
		}
	}
	
	/**
	 * removes the given $Link from ${property.name}, allowing for recursion -- whether
	 * or not the removal will call unlink${pojo.declarationName} again.
	 */ 
	public void remove${Link} ($LinkType link, boolean bothSides) {

		if ( get${PropertyName}() != null )
			get${PropertyName}().remove( link );		
			
		if ( bothSides )
			link.${other}().remove${Link}( link, false );
			
	}
	
	/**
	 * clears the set. 
	 */
	public void clear${Name}Links() {
		Iterator it = iterate${PropertyName}();
		while ( it.hasNext() )
		{
			$LinkType link = ($LinkType) it.next();
			remove${Link}( link, true );
		}
			
	}

#end
#end
################################################################################
## CLASS LEVEL EXTRA METHODS
################################################################################
##
## Link Type
##
#if( $c2j.hasMetaAttribute($clazz, "link-parent") )	
#set( $parent = $c2j.getMetaAsString($clazz, "link-parent"))
#set( $child = $c2j.getMetaAsString($clazz, "link-child"))

	public void link($parent parent, $child child) {
		setParent( parent ); 
		setChild( child );
	}
	
	public $parent parent() {
		return ($parent) getParent();
	}
	
	public $child child() {
		return ($child) getChild();
	}
#end
###########################################################
## </CustomCode>
###########################################################

$templates.PojoPropertyAccessors   

$templates.PojoToString

$templates.PojoEqualsHashcode

#else 

$templates.PojoInterfacePropertyAccessors

#end

$templates.PojoExtraClassCode

###########################################################
## <CustomCode>
###########################################################
  public boolean isValid() 
  {
      return ome.util.Validator.validate(this).isValid();
  }
  
  public ome.util.Validation validate()
  {
      return ome.util.Validator.validate(this);
  }
  
  public boolean acceptFilter(ome.util.Filter filter){
#foreach($property in $pojo.allPropertiesIterator)
#set( $fulltype = $c2j.getJavaTypeName($property,false) ) ## , $generics)
#set( $type = $c2j.unqualify($fulltype) )
#set( $get = "$pojo.getGetterSignature($property)()" )
#set( $set = "set$pojo.getPropertyName($property)" )
#set( $field = $property.name )
	  this.$property.name = ($type) filter.filter(${field.toUpperCase()}, $property.name ); 
#end ## foreach
#if($pojo.isSubclass())
  	 return super.acceptFilter(filter);
#else
	 return true;
#end
  }

#if($clazz.identifierProperty)
  public String toString(){
#set($idGetter = "${pojo.getGetterSignature($clazz.identifierProperty)}()")
	return "$pojo.declarationName"+($idGetter==null ? ":Hash_"+this.hashCode() : ":Id_"+$idGetter);
  }
#end
  
  // FIELD-FIELDS
  
  	public Set fields()
    {
	    return new HashSet(${pojo.getDeclarationName()}.FIELDS);
    }
  
#foreach($property in $pojo.allPropertiesIterator)
#set( $field = $property.name )
	public final static String ${field.toUpperCase()} = "${pojo.declarationName}_${field}";
#end ## foreach
	public final static Set FIELDS = new HashSet();
	static {
#foreach($property in $pojo.allPropertiesIterator)
#set( $field = $property.name )
	   FIELDS.add(${field.toUpperCase()});
#if($pojo.isSubclass())
	   FIELDS.addAll(${pojo.extends}.FIELDS);
#end	   
#end ## foreach
	}
	
	
	// Dynamic Getter/Setter
#if(!$pojo.isSubclass())
	protected Map _dynamicFields;
#end
	public Object retrieve(String field)
	{
		if (field == null)
		{
			return null;
#foreach($property in $pojo.allPropertiesIterator)
#set( $field = $property.name )
#set( $get = "$pojo.getGetterSignature($property)()" )
		}
		else if (field.equals(${field.toUpperCase()})) ## use == here first??
		{
			return $get;
#end ## forech
		} else {
#if($pojo.isSubclass())
	        return super.retrieve(field);
#else
			if (_dynamicFields != null)
			{
				return _dynamicFields.get(field);
			}
			return null;
#end			
		}
	}
	
	public void putAt(String field, Object value)
	{
		if (field == null)
		{
			return;
#foreach($property in $pojo.allPropertiesIterator)
#set( $field = $property.name )
#set( $set = "set$pojo.getPropertyName($property)" )
#set( $fulltype = $c2j.getJavaTypeName($property,false) ) ## , $generics)
#set( $type = $c2j.unqualify($fulltype) )
		}
		else if (field.equals(${field.toUpperCase()}))
		{
			${set}(($type)value);
#end ## foreach			
		} else {
#if($pojo.isSubclass())
		    super.putAt(field,value);
#else			
			if (_dynamicFields == null)
				_dynamicFields = new HashMap();
			
			_dynamicFields.put(field,value);
#end			
		}
	}

#if(!$pojo.isSubclass())
	protected boolean _loaded = true;
#end
	public boolean isLoaded()
	{
		return _loaded;
	}
	
	public void unload()
	{
		_loaded = false;
#foreach($property in $pojo.allPropertiesIterator)
#if(!$clazz.identifierProperty.equals($property))	
#set( $set = "set$pojo.getPropertyName($property)" )
		${set}(null);
#end ## if ! id
#end ## foreach			
#if($pojo.isSubclass())
		super.unload();
#else			

#end ## if subclass
	}
	
##parse( "$clazz.vm" ) TODO
##parse( "pojo/test.vm" )
##$templates.get("pojo/test.vm")
#set($t = "pojo/${pojo.declarationName}.vm")
##if($th.templateExists($t))$templates.get($t)#end TODO
###########################################################
## </CustomCode>
###########################################################

}

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd">
<!--
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# $Id$
#
# Copyright 2006 University of Dundee. All rights reserved.
# Use is subject to license terms supplied in LICENSE.txt
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

<!--
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Written by:  Josh Moore <josh.moore@gmx.de>
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

<!--

	Configuration for services.
	TODO add log4j configuration (e.g. update intervals)

-->


<beans>

<!-- 
  HOOKS : These beans are used to 
-->

  <bean id="dbPatchCheck"
     class="ome.services.util.DBPatchCheck"
     init-method="start" lazy-init="false">
     <property name="simpleJdbcTemplate" ref="unsafeJdbcTemplate"/>
  </bean>

  <bean id="serverVersionCheck"
     class="ome.services.util.ServerVersionCheck"
     init-method="start" destroy-method="stop" lazy-init="false"/>

  <bean id="upgradeCheck"
     class="ome.system.UpgradeCheck"
     init-method="run" lazy-init="false">
     <constructor-arg index="0" value="${omero.upgrades.url}"/>
     <constructor-arg index="1" value="${omero.version}"/>
     <constructor-arg index="2" value="server"/>
  </bean>

<!--
  Aspects/Interceptors which catch "managed:" calls to our service methods
  =======================================================================
  Possibilities are: tracing, logging, security, transactions, etc.
-->

    <bean id="statelessInterceptors" class="java.util.ArrayList">
        <constructor-arg>
            <list>
                <value>profile</value>
                <value>serviceHandler</value>
                <value>proxyHandler</value>
                <value>transactionHandler</value>
                <value>hibernateHandler</value>
                <value>eventHandler</value>
            </list>
        </constructor-arg>
    </bean>
    
    <bean id="selfManagingService" abstract="true"
        class="org.springframework.aop.framework.ProxyFactoryBean">
        <description>
        A self managed service, which must take care to properly create 
        sessions and transactions before using any other services. This
        can be achieved by properly using the Executor.Work interface.
        
        See the "executor" bean.
        </description>
        <property name="interceptorNames">
            <list>
                <value>profile</value>
                <value>serviceHandler</value>
            </list>
        </property>
    </bean>
    
	<bean id="managedService" abstract="true"
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="interceptorNames" ref="statelessInterceptors"/>
	</bean>

	<bean id="managedStatefulService" abstract="true"
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="interceptorNames">
			<list>
				<value>profile</value>
				<value>serviceHandler</value>
				<value>proxyHandler</value>
				<value>transactionHandler</value>
				<value>sessionHandler</value>
				<value>eventHandler</value>
			</list>
		</property>
	</bean>
	<bean
		       id="serviceHandler"
		    class="ome.services.util.ServiceHandler"
		lazy-init="true">
	</bean>

	<bean id="profile"
		class="org.springframework.aop.interceptor.JamonPerformanceMonitorInterceptor"/>

<!--
  Service Levels
  =======================================================================
  Abstract definitions of services which can be used when configuring
  concrete beans. Note: these Spring definitions can have a possibly
  separate inheritance hierarchy to that defined in Java. When defining
  a parent bean for a concrete service, be sure that all required properties
  are (A) filled by the abstract Spring definition and (B) available on the
  Java class.
-->

  <bean id="level1" abstract="true">
    <property name="queryFactory"      ref="queryFactory"/>
    <property name="hibernateTemplate" ref="hibernateTemplate"/>
  </bean>

  <bean id="level2" abstract="true">
    <property name="queryFactory"   ref="queryFactory"/>
    <property name="updateService" 	ref="internal:ome.api.IUpdate"/>
    <property name="queryService"	ref="internal:ome.api.IQuery"/>
    <property name="extendedMetadata" ref="extendedMetadata"/>
    <property name="securitySystem" ref="securitySystem"/>
  </bean>

  <bean id="level3" abstract="true">
    <property name="queryFactory"   ref="queryFactory"/>
    <property name="pixelsService"  ref="internal:ome.api.IPixels"/>
    <property name="pojosService" 	ref="internal:ome.api.IPojos"/>
  </bean>

  <bean id="stateful" abstract="true" class="ome.services.AbstractStatefulBean">
    <property name="queryService" ref="internal:ome.api.IQuery"/>
    <property name="securitySystem" ref="securitySystem"/>
  </bean>

  <bean name="binary" abstract="true">
    <property name="pixelsMetadata" ref="internal:ome.api.IPixels"/>
    <property name="pixelsData"     ref="/OMERO/Pixels"/>
  </bean>

  <bean name="filesystem"  abstract="true">
    <constructor-arg value="${omero.data.dir}"/>
  </bean>

<!--
  Shared resources
  =======================================================================
-->

  <bean id="executor" class="ome.services.util.Executor$Impl">
    <constructor-arg ref="securitySystem"/>
    <constructor-arg ref="transactionTemplate"/>
    <constructor-arg ref="hibernateTemplate"/>
    <constructor-arg ref="statelessInterceptors"/>
  </bean>

  <bean id="queryFactory" class="ome.services.query.QueryFactory">
    <constructor-arg>
      <list>
        <bean class="ome.services.query.ClassQuerySource"/>
        <bean class="ome.services.query.StringQuerySource"/>
      </list>
    </constructor-arg>
  </bean>
  
  <bean id="scheduler" class="ome.services.scheduler.SchedulerFactoryBean"
    depends-on="sessionManager">
    <!-- In order to slow down the scheduler background tasks, we are now
    starting it active but waiting on session-manager to accept logins,
    then it can start processing  -->
    <property name="autoStartup" value="true"/>
    <property name="schedulerName" value="OMERO.scheduler"/>
    <property name="jobDetails">
      <list>
        <ref bean="process-jobs-run" />
        <ref bean="update-cache-run" />
      </list>
    </property>
    <property name="triggers">
      <list>
        <ref bean="fullTextIndexerTrigger"/>
      </list>

    <!--Disabling trigger, since context is not properly initialized
     property name="triggers">
      <list>
        <ref bean="process-jobs-every-30-seconds" />
      </list>
    </property-->

    </property>
  </bean>

  <!-- internal: prefix because the definition is used for self-configuration.
  see BeanHelper.configure and OmeroContext.applyBeanPropertyValues. -->
  <bean id="internal:ome.services.util.OmeroAroundInvokeName" lazy-init="true"
     class="ome.services.util.OmeroAroundInvoke">
  	<property name="queryFactory" ref="queryFactory"/>
  	<property name="securitySystem" ref="securitySystem"/>
  </bean>

  <bean id="cacheManager" class="ome.tools.spring.ShutdownSafeEhcacheManagerFactoryBean"/>

</beans>

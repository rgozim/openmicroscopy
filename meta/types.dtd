<?xml version="1.0" encoding="UTF-8"?>

<!--
	Spring XML Beans DTD
	Authors: Rod Johnson, Juergen Hoeller, Alef Arendsen, Colin Sampaleanu

	This defines a simple and consistent way of creating a namespace
	of JavaBeans objects, managed by a Spring BeanFactory, read by
	XmlBeanDefinitionReader (with DefaultXmlBeanDefinitionParser).

	This document type is used by most Spring functionality, including
	web application contexts, which are based on bean factories.

	Each "bean" element in this document defines a JavaBean.
	Typically the bean class is specified, along with JavaBean properties
	and/or constructor arguments.

	Bean instances can be "singletons" (shared instances) or "prototypes"
	(independent instances). Further scopes are supposed to be built on top
	of the core BeanFactory infrastructure and are therefore not part of it.

	References among beans are supported, i.e. setting a JavaBean property
	or a constructor argument to refer to another bean in the same factory
	(or an ancestor factory).

	As alternative to bean references, "inner bean definitions" can be used.
	Singleton flags of such inner bean definitions are effectively ignored:
	Inner beans are typically anonymous prototypes.

	There is also support for lists, sets, maps, and java.util.Properties
	as bean property types or constructor argument types.

	As the format is simple, a DTD is sufficient, and there's no need
	for a schema at this point.

	XML documents that conform to this DTD should declare the following doctype:

	<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
		"http://www.springframework.org/dtd/spring-beans.dtd">
-->


<!--
	The document root. A document can contain bean definitions only,
	imports only, or a mixture of both (typically with imports first).
-->
<!ELEMENT types (
	description?,
	(type | link)*
)>

<!--
	Element containing informative text describing the purpose of the enclosing
	element. Always optional.
	Used primarily for user documentation of XML bean definition documents.
-->
<!ELEMENT description (#PCDATA)>


<!--
	Defines a single (usually named) bean.

	A bean definition may contain nested tags for constructor arguments,
	property values, lookup methods, and replaced methods. Mixing constructor
	injection and setter injection on the same bean is explicitly supported.
-->
<!ELEMENT type (
	description?,
	(field)*
)>

<!--
	Optional. Can be used to create one or more aliases illegal in an id.
	Multiple aliases can be separated by any number of spaces or commas.
-->
<!ATTLIST type name CDATA #IMPLIED>

<!--
	Each bean definition must specify the fully qualified name of the class,
	except if it pure serves as parent for child bean definitions.
-->
<!ATTLIST type parent CDATA #IMPLIED>

<!--
	Is this bean "abstract", i.e. not meant to be instantiated itself but
	rather just serving as parent for concrete child bean definitions.
	Default is false. Specify true to tell the bean factory to not try to
	instantiate that particular bean in any case.
-->
<!ATTLIST type abstract (true | false) "false">

	constructor-arg elements are also used in conjunction with the factory-method
	element to construct beans using static or instance factory methods.
-->
<!ELEMENT constructor-arg (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	The constructor-arg tag can have an optional index attribute,
	to specify the exact index in the constructor argument list. Only needed
	to avoid ambiguities, e.g. in case of 2 arguments of the same type.
-->
<!ATTLIST constructor-arg index CDATA #IMPLIED>

<!--
	The constructor-arg tag can have an optional type attribute,
	to specify the exact type of the constructor argument. Only needed
	to avoid ambiguities, e.g. in case of 2 single argument constructors
	that can both be converted from a String.
-->
<!ATTLIST constructor-arg type CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST constructor-arg ref CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "value".
-->
<!ATTLIST constructor-arg value CDATA #IMPLIED>


<!--
	Bean definitions can have zero or more properties.
	Property elements correspond to JavaBean setter methods exposed
	by the bean classes. Spring supports primitives, references to other
	beans in the same or related factories, lists, maps and properties.
-->
<!ELEMENT property (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	The property name attribute is the name of the JavaBean property.
	This follows JavaBean conventions: a name of "age" would correspond
	to setAge()/optional getAge() methods.
-->
<!ATTLIST property name CDATA #REQUIRED>

<!--
  A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST property ref CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "value".
-->
<!ATTLIST property value CDATA #IMPLIED>


<!--
	A lookup method causes the IoC container to override the given method and return
	the bean with the name given in the bean attribute. This is a form of Method Injection.
	It's particularly useful as an alternative to implementing the BeanFactoryAware
	interface, in order to be able to make getBean() calls for non-singleton instances
	at runtime. In this case, Method Injection is a less invasive alternative.
-->
<!ELEMENT lookup-method EMPTY>

<!--
	Name of a lookup method. This method should take no arguments.
-->
<!ATTLIST lookup-method name CDATA #IMPLIED>

<!--
	Name of the bean in the current or ancestor factories that the lookup method
	should resolve to. Often this bean will be a prototype, in which case the
	lookup method will return a distinct instance on every invocation. This
	is useful for single-threaded objects.
-->
<!ATTLIST lookup-method bean CDATA #IMPLIED>


<!--
	Similar to the lookup method mechanism, the replaced-method element is used to control
	IoC container method overriding: Method Injection. This mechanism allows the overriding
	of a method with arbitrary code. 
-->
<!ELEMENT replaced-method (
	(arg-type)*
)>

<!--
	Name of the method whose implementation should be replaced by the IoC container.
	If this method is not overloaded, there's no need to use arg-type subelements.
	If this method is overloaded, arg-type subelements must be used for all 
	override definitions for the method.
-->
<!ATTLIST replaced-method name CDATA #IMPLIED>

<!--
	Bean name of an implementation of the MethodReplacer interface
	in the current or ancestor factories. This may be a singleton or prototype
	bean. If it's a prototype, a new instance will be used for each method replacement.
	Singleton usage is the norm.
-->
<!ATTLIST replaced-method replacer CDATA #IMPLIED>

<!--
	Subelement of replaced-method identifying an argument for a replaced method
	in the event of method overloading.
-->
<!ELEMENT arg-type (#PCDATA)>

<!--
	Specification of the type of an overloaded method argument as a String. 
	For convenience, this may be a substring of the FQN. E.g. all the
	following would match "java.lang.String":
	- java.lang.String
	- String
	- Str
	
	As the number of arguments will be checked also, this convenience can often
	be used to save typing.
-->
<!ATTLIST arg-type match CDATA #IMPLIED>


<!--
	Defines a reference to another bean in this factory or an external
	factory (parent or included factory).
-->
<!ELEMENT ref EMPTY>

<!--
	References must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	to be checked at runtime.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
-->
<!ATTLIST ref bean CDATA #IMPLIED>
<!ATTLIST ref local IDREF #IMPLIED>
<!ATTLIST ref parent CDATA #IMPLIED>


<!--
	Defines a string property value, which must also be the id of another
	bean in this factory or an external factory (parent or included factory).
	While a regular 'value' element could instead be used for the same effect,
	using idref in this case allows validation of local bean ids by the xml
	parser, and name completion by helper tools.
-->
<!ELEMENT idref EMPTY>

<!--
	ID refs must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	potentially to be checked at runtime by bean factory implementations.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
-->
<!ATTLIST idref bean CDATA #IMPLIED>
<!ATTLIST idref local IDREF #IMPLIED>


<!--
	Contains a string representation of a property value.
	The property may be a string, or may be converted to the
	required type using the JavaBeans PropertyEditor
	machinery. This makes it possible for application developers
	to write custom PropertyEditor implementations that can
	convert strings to objects.

	Note that this is recommended for simple objects only.
	Configure more complex objects by populating JavaBean
	properties with references to other beans.
-->
<!ELEMENT value (#PCDATA)>

<!--
	The value tag can have an optional type attribute, to specify the
	exact type that the value should be converted to. Only needed
	if the type of the target property or constructor argument is
	too generic: for example, in case of a collection element.
-->
<!ATTLIST value type CDATA #IMPLIED>

<!--
	Denotes a Java null value. Necessary because an empty "value" tag
	will resolve to an empty String, which will not be resolved to a
	null value unless a special PropertyEditor does so.
-->
<!ELEMENT null (#PCDATA)>


<!--
	A list can contain multiple inner bean, ref, collection, or value elements.
	Java lists are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
	A list can also map to an array type. The necessary conversion
	is automatically performed by the BeanFactory.
-->
<!ELEMENT list (
	(bean | ref | idref | value | null | list | set | map | props)*
)>

<!--
	A set can contain multiple inner bean, ref, collection, or value elements.
	Java sets are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
-->
<!ELEMENT set (
	(bean | ref | idref | value | null | list | set | map | props)*
)>


<!--
	A Spring map is a mapping from a string key to object.
	Maps may be empty.
-->
<!ELEMENT map (
	(entry)*
)>

<!--
	A map entry can be an inner bean, ref, value, or collection.
	The key of the entry is given by the "key" attribute or child element.
-->
<!ELEMENT entry (
  key?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	Each map element must specify its key as attribute or as child element.
	A key attribute is always a String value.
-->
<!ATTLIST entry key CDATA #IMPLIED>

<!--
  A short-cut alternative to a "key" element with a "ref bean=" child element.
-->
<!ATTLIST entry key-ref CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "value".
-->
<!ATTLIST entry value CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST entry value-ref CDATA #IMPLIED>

<!--
	A key element can contain an inner bean, ref, value, or collection.
-->
<!ELEMENT key (
	(bean | ref | idref | value | null | list | set | map | props)
)>


<!--
	Props elements differ from map elements in that values must be strings.
	Props may be empty.
-->
<!ELEMENT props (
	(prop)*
)>

<!--
	Element content is the string value of the property.
	Note that whitespace is trimmed off to avoid unwanted whitespace
	caused by typical XML formatting.
-->
<!ELEMENT prop (#PCDATA)>

<!--
	Each property element must specify its key.
-->
<!ATTLIST prop key CDATA #REQUIRED>

